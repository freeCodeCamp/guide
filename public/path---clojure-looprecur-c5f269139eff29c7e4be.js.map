{"version":3,"sources":["webpack:///path---clojure-looprecur-c5f269139eff29c7e4be.js","webpack:///./.cache/json/clojure-looprecur.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/clojure-looprecur.json","module","exports","data","markdownRemark","html","fields","slug","frontmatter","title","pathContext"],"mappings":"AAAAA,cAAc,qBAERC,2EACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,2qNAA63JC,QAA64DC,KAAA,uBAA6BC,aAAgBC,MAAA,yBAAgCC,aAAgBH,KAAA","file":"path---clojure-looprecur-c5f269139eff29c7e4be.js","sourcesContent":["webpackJsonp([8799527772197826000],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/clojure-looprecur.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>You may need to understand <a href=\\\"//forum.freecodecamp.com/t/clojure-conditionals/18412\\\"><code>if</code></a> and <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\"><code>let</code></a> to fully grasp recursion in Clojure.</p>\\n<h2><code>for</code> and <code>while</code></h2>\\n<p>Clojure does not have for loops or while loops. This makes sense, if you think about it. A <code>for</code> loop changes a variable, and that’s not allowed in Clojure.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>for (var i = 0; i < 10; i++) {\\n  console.log(i);\\n}</code></pre>\\n      </div>\\n<p><code>i++</code> means that we add one to the variable <code>i</code> every time the loop finishes — a clear example of a variable being mutated.</p>\\n<p><code>while</code> loops are less obviously reliant on changing variables, but they are, just as much as for loops are.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>var i = 0;\\nwhile (i < 10) {\\n  console.log(i);\\n  i++;\\n}</code></pre>\\n      </div>\\n<p><code>while</code> loops always have a condition, like <code>i &#x3C; 10</code>, and will break if that condition is no longer true. This means that they have to have some kind of side effect (like adding 1 to <code>i</code>) so that the condition will eventually be false; otherwise, the loop would last forever.</p>\\n<h2>Recursion</h2>\\n<p>Thankfully, Clojure does have one loops of some kind. These loops use recursion — a function that calls itself. The simplest recursive algorithm is one to find a positive number factorial (5 factorial, for example, equals <code>5 * 4 * 3 * 2</code>).</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(defn fact [x]\\n  (loop [n x prod 1] ;; this works just like a 'let' binding.\\n    (if (= 1 n)  ;; this is the base case.\\n      prod\\n      (recur (dec n) (* prod n)))))</code></pre>\\n      </div>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" title=\\\":rocket:\\\" alt=\\\":rocket:\\\" class=\\\"forum-image\\\"> <a href='https://ideone.com/3iP3tI' target='_blank' rel='nofollow'>IDEOne it!</a></p>\\n<p>You’ll notice that <code>(loop [n x prod 1] ...)</code> looks quite similar to a <code>let</code> binding. It actually works in just the same way — here, we bind <code>n</code> to <code>x</code>, and <code>prod</code> to 1.</p>\\n<p>Every recursive function has a “base case”. This is the condition that makes the loop stop looping. In this case, our loop stops if <code>n = 1</code>, and returns <code>prod</code>. If <code>n</code> isn’t equal to 1, then the loop recurs.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(recur (dec n) (* prod n))</code></pre>\\n      </div>\\n<p>This <code>recur</code> function restarts the loop, but with different bindings. This time, <code>n</code> isn’t bound to <code>x</code>, but is instead bound to <code>(dec n)</code> (which means <code>decrement n</code>, or <code>n - 1</code>), and <code>prod</code> is bound to <code>(* prod n)</code>.</p>\\n<p>So when we call the function, this is what happens:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(fact 5)\\n; Loop 1: 5 != 1, so the loop recurs with 4 (5 - 1) and 5 (1 * 5).\\n; Loop 2: 4 != 1, so the loop recurs with 3 (4 - 1) and 20 (5 * 4).\\n; Loop 3: 3 != 1, so the loop recurs with 2 (3 - 1) and 60 (20 * 3).\\n; Loop 4: 2 != 1, so the loop recurs with 1 (2 - 1) and 120 (60 * 2).\\n; Loop 5: 1 == 1, so the function returns prod, which is now equal to 120.\\n; => 120</code></pre>\\n      </div>\\n<p>The ingenious thing about recursion is that the variables themselves are never changed. The only thing that changes is what <code>n</code> and <code>prod</code> <em>refer to</em>. We never say, <code>n--</code>, or <code>n += 2</code>.</p>\\n<h2>Why use loop/recur?</h2>\\n<p>You might be wondering why you would use <code>loop/recur</code> rather than simply defining a function that calls itself. Our factorial function could have been written like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(defn fact-no-loop [n]\\n  (if (= 1 n)\\n    1\\n    (* n (fact-no-loop (dec n)))))</code></pre>\\n      </div>\\n<p>This is more concise, and works in a similar way. Why would you <em>ever</em> use loop and recur?</p>\\n<h3>Tail Call Optimisation</h3>\\n<p>If you use <code>loop/recur</code>, then the compiler (the software that turns Clojure code into JVM bytecode) knows that you want to create a recursive loop. This means that it tries its hardest to optimise your code for recursion. Let’s compare the speed of <code>fact</code> and <code>fact-no-loop</code>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(time (fact 20))\\n; => \\\"Elapsed time: 0.083927 msecs\\\"\\n;    2432902008176640000\\n(time (fact-no-loop 20))\\n; => \\\"Elapsed time: 0.064937 msecs\\\"\\n;    2432902008176640000</code></pre>\\n      </div>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" title=\\\":rocket:\\\" alt=\\\":rocket:\\\" class=\\\"forum-image\\\"> <a href='https://ideone.com/tpC0Xo' target='_blank' rel='nofollow'>IDEOne it!</a></p>\\n<p>At this scale, the difference is negligible. In fact, <code>fact-no-loop</code> is occasionally faster than <code>fact</code> due to the unpredictable nature of computer memory. However, on a larger scale, this kind of optimisation can make your code much, much quicker.</p>\\n<h3>Nesting Recursion Within functions</h3>\\n<p><code>fact-no-loop</code> works without <code>loop/recur</code> because the entire function is recursive. What if we wanted part of our function to use a recursive loop, and then the rest of it to do something non-recursive? We’d have to define two entirely separate functions. Using <code>loop/recur</code> lets us use a little anonymous function instead.</p>\\n<p>| <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2\\\" title=\\\":point_left:\\\" alt=\\\":point_left:\\\" class=\\\"forum-image\\\"> Previous</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" title=\\\":book:\\\" alt=\\\":book:\\\" class=\\\"forum-image\\\"> Home <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" title=\\\":book:\\\" alt=\\\":book:\\\" class=\\\"forum-image\\\"></a> | Next <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2\\\" title=\\\":point_right:\\\" alt=\\\":point_right:\\\" class=\\\"forum-image\\\">|<br>\\n| <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\">Let Bindings</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\">Table of Contents</a> | To Be Added |</p>\",\"fields\":{\"slug\":\"/clojure/looprecur/\"},\"frontmatter\":{\"title\":\"Clojure   Looprecur\"}}},\"pathContext\":{\"slug\":\"/clojure/looprecur/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---clojure-looprecur-c5f269139eff29c7e4be.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>You may need to understand <a href=\\\"//forum.freecodecamp.com/t/clojure-conditionals/18412\\\"><code>if</code></a> and <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\"><code>let</code></a> to fully grasp recursion in Clojure.</p>\\n<h2><code>for</code> and <code>while</code></h2>\\n<p>Clojure does not have for loops or while loops. This makes sense, if you think about it. A <code>for</code> loop changes a variable, and that’s not allowed in Clojure.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>for (var i = 0; i < 10; i++) {\\n  console.log(i);\\n}</code></pre>\\n      </div>\\n<p><code>i++</code> means that we add one to the variable <code>i</code> every time the loop finishes — a clear example of a variable being mutated.</p>\\n<p><code>while</code> loops are less obviously reliant on changing variables, but they are, just as much as for loops are.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>var i = 0;\\nwhile (i < 10) {\\n  console.log(i);\\n  i++;\\n}</code></pre>\\n      </div>\\n<p><code>while</code> loops always have a condition, like <code>i &#x3C; 10</code>, and will break if that condition is no longer true. This means that they have to have some kind of side effect (like adding 1 to <code>i</code>) so that the condition will eventually be false; otherwise, the loop would last forever.</p>\\n<h2>Recursion</h2>\\n<p>Thankfully, Clojure does have one loops of some kind. These loops use recursion — a function that calls itself. The simplest recursive algorithm is one to find a positive number factorial (5 factorial, for example, equals <code>5 * 4 * 3 * 2</code>).</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(defn fact [x]\\n  (loop [n x prod 1] ;; this works just like a 'let' binding.\\n    (if (= 1 n)  ;; this is the base case.\\n      prod\\n      (recur (dec n) (* prod n)))))</code></pre>\\n      </div>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" title=\\\":rocket:\\\" alt=\\\":rocket:\\\" class=\\\"forum-image\\\"> <a href='https://ideone.com/3iP3tI' target='_blank' rel='nofollow'>IDEOne it!</a></p>\\n<p>You’ll notice that <code>(loop [n x prod 1] ...)</code> looks quite similar to a <code>let</code> binding. It actually works in just the same way — here, we bind <code>n</code> to <code>x</code>, and <code>prod</code> to 1.</p>\\n<p>Every recursive function has a “base case”. This is the condition that makes the loop stop looping. In this case, our loop stops if <code>n = 1</code>, and returns <code>prod</code>. If <code>n</code> isn’t equal to 1, then the loop recurs.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(recur (dec n) (* prod n))</code></pre>\\n      </div>\\n<p>This <code>recur</code> function restarts the loop, but with different bindings. This time, <code>n</code> isn’t bound to <code>x</code>, but is instead bound to <code>(dec n)</code> (which means <code>decrement n</code>, or <code>n - 1</code>), and <code>prod</code> is bound to <code>(* prod n)</code>.</p>\\n<p>So when we call the function, this is what happens:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(fact 5)\\n; Loop 1: 5 != 1, so the loop recurs with 4 (5 - 1) and 5 (1 * 5).\\n; Loop 2: 4 != 1, so the loop recurs with 3 (4 - 1) and 20 (5 * 4).\\n; Loop 3: 3 != 1, so the loop recurs with 2 (3 - 1) and 60 (20 * 3).\\n; Loop 4: 2 != 1, so the loop recurs with 1 (2 - 1) and 120 (60 * 2).\\n; Loop 5: 1 == 1, so the function returns prod, which is now equal to 120.\\n; => 120</code></pre>\\n      </div>\\n<p>The ingenious thing about recursion is that the variables themselves are never changed. The only thing that changes is what <code>n</code> and <code>prod</code> <em>refer to</em>. We never say, <code>n--</code>, or <code>n += 2</code>.</p>\\n<h2>Why use loop/recur?</h2>\\n<p>You might be wondering why you would use <code>loop/recur</code> rather than simply defining a function that calls itself. Our factorial function could have been written like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(defn fact-no-loop [n]\\n  (if (= 1 n)\\n    1\\n    (* n (fact-no-loop (dec n)))))</code></pre>\\n      </div>\\n<p>This is more concise, and works in a similar way. Why would you <em>ever</em> use loop and recur?</p>\\n<h3>Tail Call Optimisation</h3>\\n<p>If you use <code>loop/recur</code>, then the compiler (the software that turns Clojure code into JVM bytecode) knows that you want to create a recursive loop. This means that it tries its hardest to optimise your code for recursion. Let’s compare the speed of <code>fact</code> and <code>fact-no-loop</code>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(time (fact 20))\\n; => \\\"Elapsed time: 0.083927 msecs\\\"\\n;    2432902008176640000\\n(time (fact-no-loop 20))\\n; => \\\"Elapsed time: 0.064937 msecs\\\"\\n;    2432902008176640000</code></pre>\\n      </div>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" title=\\\":rocket:\\\" alt=\\\":rocket:\\\" class=\\\"forum-image\\\"> <a href='https://ideone.com/tpC0Xo' target='_blank' rel='nofollow'>IDEOne it!</a></p>\\n<p>At this scale, the difference is negligible. In fact, <code>fact-no-loop</code> is occasionally faster than <code>fact</code> due to the unpredictable nature of computer memory. However, on a larger scale, this kind of optimisation can make your code much, much quicker.</p>\\n<h3>Nesting Recursion Within functions</h3>\\n<p><code>fact-no-loop</code> works without <code>loop/recur</code> because the entire function is recursive. What if we wanted part of our function to use a recursive loop, and then the rest of it to do something non-recursive? We’d have to define two entirely separate functions. Using <code>loop/recur</code> lets us use a little anonymous function instead.</p>\\n<p>| <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2\\\" title=\\\":point_left:\\\" alt=\\\":point_left:\\\" class=\\\"forum-image\\\"> Previous</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" title=\\\":book:\\\" alt=\\\":book:\\\" class=\\\"forum-image\\\"> Home <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" title=\\\":book:\\\" alt=\\\":book:\\\" class=\\\"forum-image\\\"></a> | Next <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2\\\" title=\\\":point_right:\\\" alt=\\\":point_right:\\\" class=\\\"forum-image\\\">|<br>\\n| <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\">Let Bindings</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\">Table of Contents</a> | To Be Added |</p>\",\"fields\":{\"slug\":\"/clojure/looprecur/\"},\"frontmatter\":{\"title\":\"Clojure   Looprecur\"}}},\"pathContext\":{\"slug\":\"/clojure/looprecur/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/clojure-looprecur.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/clojure-looprecur.json\n// module chunks = 8799527772197826000"],"sourceRoot":""}