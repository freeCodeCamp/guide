webpackJsonp([0xc650d3cba5eaa000],{"./node_modules/json-loader/index.js!./.cache/json/miscellaneous-hash-tables-and-hashing-functions.json":function(t,n){t.exports={data:{markdownRemark:{html:"<h3>Introduction to hashing</h3>\n<p>Hashing is designed to solve the problem of needing to efficiently find or store an item in a collection.<br>\nFor example, if we have a list of 10,000 words of English and we want to check if a given word is in the list, it would be inefficient to successively compare the word with all 10,000 items until we find a match. Even if the list of words are lexicographically sorted, like in a dictionary, you will still need some time to find the word you are looking for.<br>\nHashing is a technique to make things more efficient by effectively narrowing down the search at the outset.</p>\n<h2>What is hashing?</h2>\n<p>Hashing means using some function or algorithm to map object data to some representative integer value.<br>\nThis so-called hash code (or simply hash) can then be used as a way to narrow down our search when looking for the item in the map.<br>\nGenerally, these hash codes are used to generate an index, at which the value is stored.</p>\n<h2>How hashing works</h2>\n<p>In hash tables, you store data in forms of key and value pairs. The key, which is used to identify the data, is given as an input to the hashing function. The hash code, which is an integer, is then mapped to the fixed size we have.</p>\n<p>Hash tables have to support 3 functions.</p>\n<ul>\n<li>insert (key, value)</li>\n<li>get (key)</li>\n<li>delete (key)</li>\n</ul>\n<p>Purely as an example to help us grasp the concept, let us suppose that we want to map a list of string keys to string values (for example, map a list of countries to their capital cities).<br>\nSo let’s say we want to store the data in Table in the map.</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cuba</td>\n<td>Havana</td>\n</tr>\n<tr>\n<td>England</td>\n<td>London</td>\n</tr>\n<tr>\n<td>France</td>\n<td>Paris</td>\n</tr>\n<tr>\n<td>Spain</td>\n<td>Madrid</td>\n</tr>\n<tr>\n<td>Switzerland</td>\n<td>Bern</td>\n</tr>\n</tbody>\n</table>\n<p>And let us suppose that our hash function is to simply take the length of the string.</p>\n<p>For simplicity, we will have two arrays: one for our keys and one for the values.<br>\nSo to put an item in the hash table, we compute its hash code (in this case, simply count the number of characters), then put the key and value in the arrays at the corresponding index.<br>\nFor example, Cuba has a hash code (length) of 4.<br>\nSo we store Cuba in the 4th position in the keys array, and Havana in the 4th index of the values array etc. And we end up with the following:</p>\n<table>\n<thead>\n<tr>\n<th>Position</th>\n<th>Keys array</th>\n<th>Values array</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Cuba</td>\n<td>Havana</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Spain</td>\n<td>Madrid</td>\n</tr>\n<tr>\n<td>6</td>\n<td>France</td>\n<td>Paris</td>\n</tr>\n<tr>\n<td>7</td>\n<td>England</td>\n<td>London</td>\n</tr>\n<tr>\n<td>8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>Switzerland</td>\n<td>Bern</td>\n</tr>\n</tbody>\n</table>\n<p>Now, in this specific example things work quite well.<br>\nOur array needs to be big enough to accommodate the longest string, but in this case that’s only 11 slots.<br>\nWe do waste a bit of space because, for example, there are no 1-letter keys in our data, nor keys between 8 and 10 letters. But in this case, the wasted space isn’t so bad either. Taking the length of a string is nice and fast, and so is the process of finding the value associated with a given key (certainly faster than doing up to five string comparisons).</p>\n<p>But, what do we do if our dataset has a string which has more than 11 characters?<br>\nWhat if we have one another word with 5 characters, “India”, and try assigning it to an index using our hash function. Since the index 5 is already occupied, we have to make a call on what to do with it. This is called a collision.</p>\n<p>If our dataset had a string with thousand characters, and you make an array of thousand indices to store the data, it would result in a wastage of space. If our keys were random words from English, where there are so many words with same length, using length as a hashing function would be fairly useless.</p>\n<h2>Collision Handling</h2>\n<p>Two basic methods are used to handle collisions.</p>\n<ol>\n<li>Separate Chaining</li>\n<li>Open Addressing</li>\n</ol>\n<h4>Separate Chaining</h4>\n<p>Hash collision handling by separate chaining, uses an additional data structure, preferrably linked list for dynamic allocation, into buckets. In our example, when we add India to the dataset, it is appended to the linked list stored at the index 5, then our table would look like this.</p>\n<table>\n<thead>\n<tr>\n<th>Position</th>\n<th>Linked List Heads</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td><a href='https://en.wikipedia.org/wiki/Linear_probing' target='_blank' rel='nofollow'>\nCuba-Havana]</td>\n</tr>\n<tr>\n<td>5</td>\n<td>[Spain-Madrid] -> [India-Delhi]</td>\n</tr>\n<tr>\n<td>6</td>\n<td>[France-Paris]</td>\n</tr>\n<tr>\n<td>7</td>\n<td>[England-London]</td>\n</tr>\n<tr>\n<td>8</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>[Switzerland-Bern]</td>\n</tr>\n</tbody>\n</table>\n<p>To find an item we first go to the bucket and then compare keys. This is a popular method, and if a list of links is used the hash never fills up. The cost for <code>get(k)</code> is on average <code>O(n)</code> where n is the number of keys in the bucket, total number of keys be N.<br>\nThe problem with separate chaining is that the data structure can grow with out bounds.</p>\n<h4>Open Addressing</h4>\n<p>Open addressing does not introduce any new data structure. If a collision occurs then we look for availability in the next spot generated by an algorithm. Open Addressing is generally used where storage space is a restricted, i.e. embedded processors. Open addressing not necessarily faster then separate chaining.</p>\n<p>Methods for Open Addressing</p>\n<ul>\n<li>[Linear Probing</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Quadratic_probing' target='_blank' rel='nofollow'>Quadratic Probing</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Double_hashing' target='_blank' rel='nofollow'>Double Hashing</a></li>\n</ul>\n<h2>How to use hashing in your code.</h2>\n<h4>Python</h4>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-none\"><code>   # Few languages like Python, Ruby come with an in-built hashing support.\n   # Declaration\n    my_hash_table = {}\n    my_hash_table = dict()\n\n   # Insertion\n    my_hash_table[key] = value\n\n   # Look up\n    value = my_hash_table.get(key) # returns None if the key is not present || Deferred in python 3, available in python 2\n    value = my_hash_table[key] # throws a ValueError exception if the key is not present\n\n    # Deletion\n    del my_hash_table[key] # throws a ValueError exception if the key is not present\n\n    # Getting all keys and values stored in the dictionary\n    keys = my_hash_table.keys()\n    values = my_hash_table.values()</code></pre>\n      </div>\n<p><img src=\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\" title=\":rocket:\" alt=\":rocket:\" class=\"forum-image\"> <a href='https://repl.it/CVtK' target='_blank' rel='nofollow'>Run Code</a></p>\n<h4>Java</h4>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-none\"><code>    // Java doesn't include hashing by default, you have to import it from java.util library\n    // Importing hashmaps\n    import java.util.HashMap;\n\n   // Declaration\n    HashMap<Integer, Integer> myHashTable = new HashMap<Integer, Integer>(); // declares an empty map.\n\n   // Insertion\n    myHashTable.put(key, value);\n\n   // Deletion\n    myHashtable.remove(key);\n\n    // Look up\n    myHashTable.get(key); // returns null if the key K is not present\n    myHashTable.containsKey(key); // returns a boolean value, indicating the presence of a key\n\n    // Number of key, value pairs in the hash table\n    myHashTable.size();</code></pre>\n      </div>\n<p><img src=\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\" title=\":rocket:\" alt=\":rocket:\" class=\"forum-image\"> <a href='https://repl.it/CVt1' target='_blank' rel='nofollow'>Run Code</a></p>\n<h2>Resources</h2>\n<ul>\n<li>For further reading, you many want to try this <a href='http://geeksquiz.com/hashing-set-1-introduction/' target='_blank' rel='nofollow'>link</a>, which explains hashing using a different example.</li>\n<li><a href='https://www.youtube.com/watch?v=x05KubVlh_M' target='_blank' rel='nofollow'>Hashing in 60 seconds</a>.</li>\n<li><a href='https://www.youtube.com/watch?v=HRzg0SzFLQQ' target='_blank' rel='nofollow'>Cuckoo Hashing</a></li>\n<li><a href='https://www.youtube.com/watch?v=jznJKL0CrxM' target='_blank' rel='nofollow'>Consisten Hashing</a></li>\n<li><a href='https://www.youtube.com/watch?v=-SuTGoFYjZs' target='_blank' rel='nofollow'>Bloom Filters</a></li>\n<li><a href='https://www.youtube.com/watch?v=D65JQ0qQwZk' target='_blank' rel='nofollow'>Hashing Strategies</a></li>\n<li><a href='https://crackstation.net/hashing-security.htm' target='_blank' rel='nofollow'>Password Hashing</a></li>\n<li><a href='http://stackoverflow.com/questions/326699/difference-between-hashing-a-password-and-encrypting-it' target='_blank' rel='nofollow'>Difference between Hashing and encrypting</a></li>\n</ul>",fields:{slug:"/miscellaneous/hash-tables-and-hashing-functions/"},frontmatter:{title:"Hash Tables and Hashing Functions"}}},pathContext:{slug:"/miscellaneous/hash-tables-and-hashing-functions/"}}}});
//# sourceMappingURL=path---miscellaneous-hash-tables-and-hashing-functions-f734b1bef22460321870.js.map