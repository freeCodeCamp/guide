webpackJsonp([0xaa77fb7a7ec91000],{"./node_modules/json-loader/index.js!./.cache/json/miscellaneous-data-structure-linked-list.json":function(e,n){e.exports={data:{markdownRemark:{html:'<p>Just like a garland is made with flowers, a linked list is made up of nodes. We call every flower on this particular garland to be a node. And each of the node points to the next node in this list as well as it has data (here it is type of flower).</p>\n<h2>Types</h2>\n<ol>\n<li>Singly Linked List</li>\n</ol>\n<p>Singly linked lists contain nodes which have a <code>data</code> field as well as a <code>next</code> field, which points to the next node in the sequence. Operations that can be performed on singly linked lists are insertion, deletion and traversal.</p>\n<p>`</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>Singly Link List</code></pre>\n      </div>\n<hr>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>   head\n    |\n    |\n  +-----+--+      +-----+--+      +-----+------+\n  |  1  |o----->  |  2  |o----->  |  3  | NULL |\n  +-----+--+      +-----+--+      +-----+------+</code></pre>\n      </div>\n<p>`</p>\n<p>Application</p>\n<p>Internal implementation of CPython, the frames and evaluated variables are kept on a stack.</p>\n<p>For this we need to iterate only forward aur get the head, therefore singly linked-list is used.</p>\n<ol>\n<li>Doubly Linked List</li>\n</ol>\n<p>Doubly linked lists contain node which have <code>data</code> field, <code>next</code> field and another link field <code>prev</code> pointing to the previous node in the sequence.</p>\n<p>`</p>\n<p>Doubly Linked List</p>\n<hr>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>          head\n           |\n           |\n  +------+-----+--+    +--+-----+--+       +-----+------+\n  |      |     |o------>  |     |o------>  |     |      |\n  | NULL |  1  |          |  2  |          |  3  | NULL |\n  |      |     |  <------o|     |  <------o|     |      |\n  +------+-----+--+    +--+-----+--+       +-----+------+</code></pre>\n      </div>\n<p>`</p>\n<p>Application</p>\n<p>The browser cache which allows you to hit the BACK and FORWARD button. Here we need to maintain a doubly linked list, with <code>URLs</code> as data field, to allow access in both direction. To go to previous URL we will use <code>prev</code> field and to go to next page we will use <code>next</code> field.</p>\n<ol>\n<li>Circular Linked List</li>\n</ol>\n<p>Circular linked lists is a singly linked list in which last node, <code>next</code> field points to first node in the sequence.</p>\n<p>`</p>\n<p>Circular Linked List</p>\n<hr>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>     head\n      |\n      |\n    +-----+--+      +-----+--+      +-----+--+</code></pre>\n      </div>\n<p>—> | 1 |o-----> | 2 |o-----> | 3 |o----<br>\n| +-----+—+ +-----+—+ +-----+—+ |<br>\n| |</p>\n<hr>\n<p>`</p>\n<p><strong>Application</strong></p>\n<p>Timesharing problem solved by the operating system.</p>\n<p>In a timesharing environment, the operating system must maintain a list of present users and must alternately allow each user to use a small portion of CPU time, one user at a time. The operating system will pick a user, let him/her use a small amount of CPU time and then move on to the next user.</p>\n<p>For this application, there should be no NULL pointers unless there is absolutely no one requesting CPU time, i.e list is empty.</p>\n<h2>Basic Operations</h2>\n<ol>\n<li>Insertion</li>\n</ol>\n<p>To add a new element to the list.</p>\n<p>`</p>\n<p>Insertion at the beginning</p>\n<hr>\n<ul>\n<li>Create a new node with given data.</li>\n<li>Point new node’s <code>next</code> to old <code>head</code>.</li>\n<li>Point <code>head</code> to this new node.</li>\n</ul>\n<p>Insertion in the middle/end</p>\n<hr>\n<p>Insertion after node X.</p>\n<ul>\n<li>Create a new node with given data.</li>\n<li>Point new node’s <code>next</code> to old X’s <code>next</code>.</li>\n<li>Point X’s <code>next</code> to this new node.<br>\n`</li>\n</ul>\n<p><strong>Time Complexity: O(1)</strong></p>\n<ol>\n<li>Deletion</li>\n</ol>\n<p>To delete existing element from the list.</p>\n<p>`</p>\n<p>Deletion at the beginning</p>\n<hr>\n<ul>\n<li>Get the node pointed by <code>head</code> as Temp.</li>\n<li>Point <code>head</code> to Temp’s <code>next</code>.</li>\n<li>Free memory used by Temp node.</li>\n</ul>\n<p>Deletion in the middle/end</p>\n<hr>\n<p>Deletion after node X.</p>\n<ul>\n<li>Get the node pointed by <code>X</code> as Temp.</li>\n<li>Point X’s <code>next</code> to Temp’s <code>next</code>.</li>\n<li>Free memory used by Temp node.<br>\n`</li>\n</ul>\n<p><strong>Time Complexity: O(1)</strong></p>\n<ol>\n<li>Traversing</li>\n</ol>\n<p>To travel across the list.</p>\n<p>`</p>\n<p>Traversal</p>\n<hr>\n<ul>\n<li>Get the node pointed by <code>head</code> as Current.</li>\n<li>Check if Current is not null and display it.</li>\n<li>Point Current to Current’s <code>next</code> and move to above step.<br>\n`</li>\n</ul>\n<p><strong>Time Complexity: O(n) // Here n is size of link-list</strong></p>\n<h2>Implementation</h2>\n<h3>C++ implementation of singly linked list</h3>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>// Header files\n#include <iostream>\n\nstruct node\n{\n    int data;\n    struct node *next;\n};\n\n// Head pointer always points to first element of the linked list\nstruct node *head = NULL;</code></pre>\n      </div>\n<h4>Printing data in each node</h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>// Display the list\nvoid printList()\n{\n    struct node *ptr = head;\n\n    // Start from the beginning\nwhile(ptr != NULL)\n{\n    std::cout << ptr->data << " ";\n    ptr = ptr->next;\n}\n\nstd::cout << std::endl;\n}</code></pre>\n      </div>\n<h4>Insertion at the beginning</h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>// Insert link at the beginning\nvoid insertFirst(int data)\n{\n    // Create a new node\n    struct node *new_node = new struct node;\n\n    new_node->data = data;\n\n// Point it to old head\nnew_node->next = head;\n\n// Point head to new node\nhead = new_node;\n\nstd::cout << "Inserted successfully" << std::endl;\n}</code></pre>\n      </div>\n<h4>Deletion at the beginning</h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>// Delete first item\nvoid deleteFirst()\n{\n    // Save reference to head\n    struct node *temp = head;\n\n    // Point head to head\'s next\nhead = head->next;\n\n// Free memory used by temp\ntemp = NULL:\ndelete temp;\n\nstd::cout << "Deleted successfully" << std::endl;\n}</code></pre>\n      </div>\n<h4>Size</h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>// Find no. of nodes in link list\nvoid size()\n{\n    int length = 0;\n    struct node *current;\n\n    for(current = head; current != NULL; current = current->next)\n{\n    length++;\n}\n\nstd::cout << "Size of Linked List is " << length << std::endl;\n}</code></pre>\n      </div>\n<h4>Searching</h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>// Find node with given data\nvoid find(int data){\n\n    // Start from the head\nstruct node* current = head;\n\n// If list is empty\nif(head == NULL)\n{\n    std::cout << "List is empty" << std::endl;\n    return;\n}\n\n// Traverse through list\nwhile(current->data != data){\n\n    // If it is last node\n    if(current->next == NULL){\n        std::cout << "Not Found" << std::endl;\n        return;\n    }\n    else{\n        // Go to next node\n        current = current->next;\n    }\n}\n\n// If data found\nstd::cout << "Found" << std::endl;\n}</code></pre>\n      </div>\n<h4>Deletion after a node</h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>// Delete a node with given data\nvoid del(int data){\n\n    // Start from the first node\nstruct node* current = head;\nstruct node* previous = NULL;\n\n// If list is empty\nif(head == NULL){\n    std::cout << "List is empty" << std::endl;\n    return ;\n}\n\n// Navigate through list\nwhile(current->data != data){\n\n    // If it is last node\n    if(current->next == NULL){\n        std::cout << "Element not found" << std::endl;\n        return ;\n    }\n    else {\n        // Store reference to current node\n        previous = current;\n        // Move to next node\n        current = current->next;\n    }\n\n}\n\n// Found a match, update the node\nif(current == head) {\n    // Change head to point to next node\n    head = head->next;\n}\nelse {\n    // Skip the current node\n    previous->next = current->next;\n}\n\n// Free space used by deleted node\ncurrent = NULL;\ndelete current;\nstd::cout << "Deleted succesfully" << std::endl;\n}</code></pre>\n      </div>\n<p><img src="https://forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=3" title=":rocket:" alt=":rocket:" class="forum-image"> <a href=\'https://repl.it/CXVt/1\' target=\'_blank\' rel=\'nofollow\'>Run Code</a></p>\n<h3>Python Implementation of Singly Linked List</h3>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>class Node(object):\n    # Constructor\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\n\n    # Function to get data\ndef get_data(self):\n    return self.data\n\n# Function to get next node\ndef get_next(self):\n    return self.next\n\n# Function to set next field\ndef set_next(self, new_next):\n    self.next = new_next\nclass LinkedList(object):\n    def __init__(self, head=None):\n        self.head = head</code></pre>\n      </div>\n<h4>Insertion</h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>    # Function to insert data\ndef insert(self, data):\n    # new_node is a object of class Node\n    new_node = Node(data)\n    new_node.set_next(self.head)\n    self.head = new_node\n    print("Node with data " + str(data) + " is created succesfully")</code></pre>\n      </div>\n<h4>Size</h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>    # Function to get size\ndef size(self):\n    current = self.head\n    count = 0\n    while current:\n        count += 1\n        current = current.get_next()\n    print("Size of link list is " + str(count))</code></pre>\n      </div>\n<h4>Searching</h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>    # Function to search a data\ndef search(self, data):\n    current = self.head\n    found = False\n    while current and found is False:\n        if current.get_data() == data:\n            found = True\n        else:\n            current = current.get_next()\n    if current is None:\n        print("Node with data " + str(data) + " is not present")\n    else:\n        print("Node with data " + str(data) + " is found")</code></pre>\n      </div>\n<h4>Deletion after a node</h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>    # Function to delete a node with data\ndef delete(self, data):\n    current = self.head\n    previous = None\n    found = False\n    while current and found is False:\n        if current.get_data() == data:\n            found = True\n        else:\n            previous = current\n            current = current.get_next()\n    if current is None:\n        print("Node with data " + str(data) + " is not in list")\n    elif previous is None:\n        self.head = current.get_next()\n        print("Node with data " + str(data) + " is deleted successfully")\n    else:\n        previous.set_next(current.get_next())\n        print("Node with data " + str(data) + " is deleted successfully")</code></pre>\n      </div>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" title=":rocket:" alt=":rocket:" class="forum-image"> <a href=\'https://repl.it/CVq3/2\' target=\'_blank\' rel=\'nofollow\'>Run Code</a></p>\n<p><strong>Advantages</strong></p>\n<ol>\n<li>Linked lists are a dynamic data structure, which can grow and shrink, allocating and deallocating memory while the program is running.</li>\n<li>Insertion and deletion of node are easily implemented in a linked list at any position.</li>\n</ol>\n<p><strong>Disadvantages</strong></p>\n<ol>\n<li>They use more memory than arrays because of the memory used by their pointers (<code>next</code> and <code>prev</code>).</li>\n<li>Random access is not possible in linked list. We have to access nodes sequentially.</li>\n<li>It’s more complex than array. If a language supports array bound check automatically, Arrays would serve you better.</li>\n</ol>\n<h4>Note</h4>\n<p>We have to use free() in C and delete in C++ to free the space used by deleted node, whereas, in Python and Java free space is collected automatically by garbage collector.</p>',fields:{slug:"/miscellaneous/data-structure-linked-list/"},frontmatter:{title:"Data Structure Linked List"}}},pathContext:{slug:"/miscellaneous/data-structure-linked-list/"}}}});
//# sourceMappingURL=path---miscellaneous-data-structure-linked-list-afbc322c2de956dbe603.js.map